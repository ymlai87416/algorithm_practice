package Facebook.Y2021.Round1;

import Facebook.Y2019.Quali.B;

import java.io.File;
import java.io.PrintStream;
import java.util.*;

import static java.lang.Integer.parseInt;

public class C {
    static String   FILENAME;
    static Scanner sc;
    static String   IN;
    static String   OUT;
    static PrintStream out;

    static{
        try{
            //IN = "C:\\GitProjects\\algorithm_practice\\java\\src\\main\\java\\Facebook\\Y2021\\Quali\\A2-test.in";
            IN = "C:\\GitProjects\\algorithm_practice\\java\\src\\main\\java\\Facebook\\Y2021\\Round1\\C_input.txt";
            OUT = "C:\\GitProjects\\algorithm_practice\\java\\src\\main\\java\\Facebook\\Y2021\\Round1\\C_output.txt";
            //IN = null;
            if(IN == null)
                sc = new Scanner(System.in);
            else
                sc = new Scanner(new File(IN));
            if(OUT == null)
                out = new PrintStream(System.out);
            else out = new PrintStream(OUT);
        }
        catch(Exception ex) {
            ex.printStackTrace();
        }
    }

    boolean debugflag = true;
    private void debug(String s){
        if(debugflag) {
            //System.out.println(s);
            System.out.print("\033[0;34m" + s + "\033[0;30m");
        }

    }

    private void debug(Object... s){
        if(debugflag) {
            //System.out.println(s);
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < s.length; i++) {
                sb.append(s[i].toString() + " ");
            }
            System.out.println("\033[0;34m" + sb.toString() + "\033[0;30m");
        }
    }


    //UnionFind uf = new UnionFind(800000);

    private long solve(int N, ArrayList<Edge> edges) {

        edges.sort(new Comparator<Edge>() {
            @Override
            public int compare(Edge o1, Edge o2) {
                if(o1.cap == o2.cap) {
                    if (o1.u == o2.u)
                        return o1.v - o2.v;
                    else
                        return o1.u - o2.u;
                }
                else
                    return o2.cap - o1.cap;
            }
        });


        //uf.init();
        
        //now add the edge one by one and then we can
        //a edge is taken out
        //u and v
        //they representing 2 tree, not yet joined.
        //tree1: x1 nodes, x1-1 edges
        //tree2: x2 nodes, x2-1 edges
        //now for each edges in both tree, do the following

        //tree1 edges separate += tree2 node * edge cap
        //tree2 edges separate += tree1 node * edge cap

        HashMap<Integer, ArrayList<Edge>> setEdges = new HashMap<>();

        debug("New case:\n");

        long totalSum = 0;
        for (int i = 0; i < edges.size(); i++) {
            Edge currE = edges.get(i);
            debug("add edge " + currE.u + " " + currE.v + "\n");
            /*
            int ui = uf.findSet(currE.u);
            int vi = uf.findSet(currE.v);

            int uSize = uf.getSetSize(ui);
            int vSize = uf.getSetSize(vi);


            ArrayList<Edge> ue =  setEdges.getOrDefault(ui, null);
            ArrayList<Edge> ve = setEdges.getOrDefault(vi, null);


            //now a dfs for the whole thing
            //now each edge is add
            if(ue != null) {
                for (int j = 0; j < ue.size(); j++) {
                    ue.get(j).sep += currE.cap * vSize;
                }
            }

            if(ve != null){
                for (int j = 0; j < ve.size(); j++) {
                    ve.get(j).sep += currE.cap * uSize;
                }
            }
             */

            //now traverse both tree
            for (int j = 0; j < N+1; j++) {
                visited[j] =false;
            }
            int uSize = dfsCount(currE.u, 0);
            int vSize = dfsCount(currE.v, 0);
            for (int j = 0; j < N+1; j++) {
                visited[j] =false;
            }
            dfsCount(currE.u, currE.cap*vSize);
            dfsCount(currE.v, currE.cap*uSize);

            //use algo to check the root of both tree
            currE.sep += currE.cap * (uSize * vSize);

            totalSum += currE.cap * uSize * vSize;

            currE.active=true;

            for (int j = 0; j < edges.size(); j++) {
                if(edges.get(j).active){
                    debug("" + edges.get(j).u + " " + edges.get(j).v + " " + edges.get(j).cap + "\n");
                }
            }
            debug("+====\n");
            /*
            uf.unionSet(currE.u, currE.v);

            int nSetIdx =uf.findSet(currE.u);

            ArrayList newList = new ArrayList();
            if(ue!=null) newList.addAll(ue);
            if(ve!=null) newList.addAll(ve);
            newList.add(currE);

            setEdges.remove(ui); setEdges.remove(vi);
            setEdges.put(nSetIdx, newList);

             */
        }

        //now we have edges with O(N)
        long result = 1;
        for (int i = 0; i < edges.size(); i++) {

            debug(totalSum - edges.get(i).sep);
            result = result * (totalSum - edges.get(i).sep) % 1000000007;
        }
        debug("\n");

        return result;
    }

    int[] childNode = new int[800001];
    boolean[] visited = new boolean[800001];

    //return number of node within the subtree
    int dfsCount(int u, int cap){
        ArrayList<Edge> edges =nodes.get(u);

        int totalCnt= 0 ;

        for (int i = 0; i < edges.size(); i++) {
            Edge currE = edges.get(i);
            if(!currE.active) continue;
            visited[u] = true;
            int v = currE.u == u ? currE.v : currE.u;
            if(!visited[v]) {
                int count = dfsCount(v, cap);
                //now the edge is add with cap
                currE.sep += cap * count;

                totalCnt += count;
            }
        }

        return totalCnt+1;
    }

    int[] size = new int[800001];
    int iterativeCount(int root){
        Stack<Integer> bottomUpOrder = new Stack<>();
        Queue<Integer> q = new LinkedList<>();
        q.offer(root);

        while(!q.isEmpty()){
            int u = q.poll();
            bottomUpOrder.push(u);
            ArrayList<Edge> ue = nodes.get(u);
            boolean isLeave = true;
            for (int i = 0; i < ue.size(); i++) {
                Edge e = ue.get(i);
                if(e.active ){
                    int v = e.u == u ? e.v : e.u;

                    if(!visited[v]) {
                        q.offer(v);
                        isLeave = false;
                    }
                }
            }

            if(isLeave) size[u] = 1;
            else size[u] = 0;
        }

        //now we got the leave node on the top, and we can just sum it up
        while(!bottomUpOrder.isEmpty()){
            int u = bottomUpOrder.pop();
            if(size[u] == 1) continue;
            else{
                ArrayList<Edge> ue = nodes.get(u);
                for (int i = 0; i < ue.size(); i++) {
                    Edge e = ue.get(i);
                    int v = e.u == u ? e.v : e.u;
                    if(size[v] != 0) {
                        size[u] += size[v];
                    }
                }
            }
        }

        return size[root];
    }


    HashMap<Integer, ArrayList<Edge>> nodes = new HashMap<>();

    private void run() throws Exception {
        // out = new PrintStream(new FileOutputStream(OUT));
        int t = sc.nextInt();
        for (int i = 1; i <= t; i++) {
            out.print("Case #" + i + ": ");
            int N = sc.nextInt();

            int u, v, c;
            nodes.clear();
            ArrayList<Edge> edges = new ArrayList<>();
            for (int j = 0; j < N-1; j++) {
                u = sc.nextInt(); v = sc.nextInt(); c = sc.nextInt();
                Edge e = new Edge(u, v, c);

                if(nodes.containsKey(u)) nodes.get(u).add(e);
                else{
                    ArrayList<Edge> newList = new ArrayList<>();
                    newList.add(e);
                    nodes.put(u, newList);
                }
                if(nodes.containsKey(v)) nodes.get(v).add(e);
                else{
                    ArrayList<Edge> newList = new ArrayList<>();
                    newList.add(e);
                    nodes.put(v, newList);
                }

                edges.add(e);
            }

            long r = solve(N, edges);
            out.println(r);

        }
        sc.close();
        out.close();
    }

    public static void main(String args[]) throws Exception {
        new C().run();
    }

    static class Edge{
        public int cap;
        public int u;
        public int v;
        public long sep;
        public boolean active;
        public Edge(int u, int v, int cap){
            this.u = u; this.v = v; this.cap = cap;
            active = false;
        }
    }

    static class UnionFind { // OOP style
        int[] p;
        int[] rank;
        int[] size;

        UnionFind(int N) {
            p = new int[N];
            rank = new int[N];
            size = new int[N];
            for (int i = 0; i < N; i++) p[i] = i;
        }

        void init(){
            for (int i = 0; i < p.length; i++) p[i] = i;
            Arrays.fill(rank, 0);
            Arrays.fill(size, 1);
        }
        int findSet(int i) { return (p[i] == i) ? i : (p[i] = findSet(p[i])); }

        boolean isSameSet(int i, int j) { return findSet(i) == findSet(j); }

        void unionSet(int i, int j) {
            if (!isSameSet(i, j)) { // if from different set
                int x = findSet(i), y = findSet(j);
                if (rank[x] > rank[y]) {
                    p[y] = x; // rank keeps the tree short
                    size[x] += size[y];
                }
                else {
                    p[x] = y;
                    size[y] += size[x];
                    if (rank[x] == rank[y])
                        rank[y]++;
                }
            }
        }

        int getSetSize(int i){
            return size[i];
        }
    };


}
